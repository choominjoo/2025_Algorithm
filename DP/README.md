# 🧮 동적계획법 (Dynamic Programming, DP)

## 📘 개요
동적계획법(Dynamic Programming, DP)은 **문제를 작은 부문제(subproblem)** 로 나누고,  
이미 계산한 부문제의 해를 **저장소에 보관하여 재활용**함으로써 중복 계산을 줄이는 알고리즘 기법이다.

> ✅ **중첩된 부문제(Overlapping Subproblems)** 와  
> ✅ **최적 부분 구조(Optimal Substructure)**  
> 두 가지 조건을 만족하는 문제에 효과적이다.

---

## 🔢 피보나치 수열 (Fibonacci Sequence)

### 정의
- 0번째 수 = 0  
- 1번째 수 = 1  
- n번째 수 = f(n-1) + f(n-2)  
- 수열: 0, 1, 1, 2, 3, 5, 8, 13, 21, …

점화식:
```
f(n) = 0            if n = 0
f(n) = 1            if n = 1
f(n) = f(n-1)+f(n-2)  if n ≥ 2
```

---

## 🪓 단순 재귀 (Divide & Conquer 방식)

```python
def f(n):
    if n < 2:
        return n
    return f(n-1) + f(n-2)

print(f(5))
# print(f(60))  # 실행 시 매우 오래 걸림
```

### 📊 문제점
- 중복 계산 발생 (예: f(3), f(2) 다중 호출)
- 시간복잡도 **O(2ⁿ)** (지수적 증가)
- 동일 계산을 반복 수행

> 💡 같은 부문제를 여러 번 푸는 “비효율적인 재귀 호출” 구조

---

## 🧠 Top-Down 방식 (메모이제이션 Memoization)

### 개념
- 재귀 기반 접근
- 이미 계산한 결과를 **딕셔너리나 리스트에 저장**하여 재사용

```python
def f(n):
    if n in memo:
        return memo[n]
    if n < 2:
        memo[n] = n
    else:
        memo[n] = f(n-1) + f(n-2)
    return memo[n]

memo = {}
print(f(6))   # 8
print(memo)   # {0:0, 1:1, 2:1, 3:2, 4:3, 5:5, 6:8}
```

### 시간·공간 복잡도
- **시간복잡도:** O(n)  
- **공간복잡도:** O(n)

> ✅ 함수 호출을 줄이면서 재귀의 장점을 살린 구현 방식

---

## 🧩 Bottom-Up 방식 (상향식 DP)

### 개념
- 반복문을 사용해 작은 문제부터 큰 문제로 확장
- 각 단계의 결과를 리스트에 저장

```python
def f(n):
    dp = [0] * (n + 1)
    dp[0], dp[1] = 0, 1
    for i in range(2, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n]

print(f(6))   # 8
```

### 동작 방식
| 단계 | dp 배열 상태          |
|------|-----------------------|
| 초기 | [0, 1, 0, 0, 0, 0, 0] |
| i=2  | [0, 1, 1, 0, 0, 0, 0] |
| i=3  | [0, 1, 1, 2, 0, 0, 0] |
| i=4  | [0, 1, 1, 2, 3, 0, 0] |
| i=5  | [0, 1, 1, 2, 3, 5, 0] |
| i=6  | [0, 1, 1, 2, 3, 5, 8] |

### 시간·공간 복잡도
- **시간복잡도:** O(n)  
- **공간복잡도:** O(n)

> ✅ 재귀 호출 없이 간결하며 효율적  
> 💡 Top-down보다 함수 호출 오버헤드가 없음

---

## 🧮 동적계획법 정리

| 구분 | 접근 방식 | 구현 형태 | 시간복잡도 | 공간복잡도 | 특징 |
|------|-------------|-------------|---------------|---------------|--------|
| 단순 재귀 | 분할정복 | 재귀 | O(2ⁿ) | O(n) | 중복 계산 많음 |
| Top-Down DP | 메모이제이션 | 재귀 + 저장 | O(n) | O(n) | 코드 간결, 재귀 호출 |
| Bottom-Up DP | 반복적 접근 | 반복문 + 저장 | O(n) | O(n) | 효율적, 호출 오버헤드 없음 |

---

## 🧩 동적계획법의 핵심 요건
- **중첩된 부문제(Overlapping Subproblems)**  
  → 동일한 하위 문제를 여러 번 푸는 구조  
- **최적 부분 구조(Optimal Substructure)**  
  → 전체 문제의 최적해가 부문제의 최적해 조합으로 얻어짐

---

## 📚 참고문헌
- 이상호, *컴퓨터 알고리즘의 이해*, 이화여자대학교출판부, 2015  
- 이형원, *차근차근 이해하는 알고리즘*, 정익사, 2021  
- 양성봉, *알기 쉬운 알고리즘*, 생능출판사, 2013  
- John Bentley, *생각하는 프로그래밍*, 인사이트, 2003  
- Robert Sedgewick & Kevin Wayne, *Algorithms (4th Edition)*, 길벗, 2018  
- T. Cormen et al., *Introduction to Algorithms (3rd Edition)*, 2009  
