# 🧩 그리디(Greedy) 알고리즘 요약

## 📖 개요
그리디 알고리즘(Greedy Method, 탐욕법)은 **각 단계에서 현재 가장 좋아 보이는 선택(국지적 최적해)** 을 반복하여 **전체 문제의 해(전역적 최적해)** 를 구하려는 방법이다.  
단순하고 직관적인 접근이지만, **항상 최적해를 보장하지는 않는다.**

> ✅ 각 단계의 탐욕적 선택이 전체적으로도 최적이라면 최적해를 구할 수 있음  
> ❌ 그렇지 않다면 근사해(approximation)만 구할 수 있음

---

## 💰 동전 교환 문제 (Coin Change Problem)

### 문제 정의
서로 다른 액면가의 동전들로 **거스름돈 `w`를 최소 개수의 동전으로 거슬러주는 방법** 찾기.

### 탐욕적 접근
> “항상 가장 큰 액면가의 동전부터 가능한 한 많이 사용한다.”

```python
def coinChange(coin, money):
    coin.sort(reverse=True)
    count = 0
    S = []
    for i in range(len(coin)):
        quantity = money // coin[i]
        S.append((coin[i], quantity))
        count += quantity
        money = money % coin[i]
    return count, S

coin = [1, 5, 10, 50, 100, 500]
money = 1237
print(coinChange(coin, money))
```

**출력 예시**
```
동전 정보 S = [(500, 2), (100, 2), (50, 0), (10, 3), (5, 1), (1, 2)]
총 동전 개수 = 10개
```

> ✅ 한국 동전 시스템에서는 탐욕법이 최적해를 보장  
> ❌ 미국 25¢, 20¢, 10¢, 5¢, 1¢ 시스템에서는 탐욕법이 최적해를 보장하지 않음

---

## 🎒 분수 배낭 문제 (Fractional Knapsack Problem)

### 문제 정의
- 물건 이름, 이익, 무게가 주어질 때  
- 배낭 용량 `M`을 넘지 않게 **이익을 최대화**하는 방법 찾기  
- 단, 물건은 분할하여 담을 수 있다.

### 탐욕적 전략
> “무게당 이익이 가장 큰 물건부터 가능한 한 많이 담는다.”

```python
def ft(Name, Profit, Weight, C):
    L = list(zip(Name, Profit, Weight))
    S, maxP = [], 0
    L.sort(key=lambda k: k[1]/k[2], reverse=True)
    for n, p, w in L:
        if w > C:
            S.append((n, C/w))
            maxP += C * p / w
            break
        S.append((n, 1))
        C -= w
        maxP += p
    return maxP, S

Name = ['A', 'B', 'C']
Profit = [150, 100, 150]
Weight = [10, 20, 5]
Capacity = 20

print(ft(Name, Profit, Weight, Capacity))
```

**출력 예시**
```
최대 이익: 325.0
선택 정보: [('C', 1), ('A', 1), ('B', 0.25)]
```

> ✅ 분수 배낭 문제는 탐욕법으로 **항상 최적해 가능**  
> ❌ 0-1 배낭 문제는 탐욕법으로 **최적해 불가능**, 동적계획법 필요

---

## 🧭 여행하는 외판원 문제 (Traveling Salesperson Problem, TSP)

### 문제 정의
모든 도시를 단 한 번씩 방문하고 출발 도시로 돌아오는 **최소 비용 경로** 찾기.  
> 그래프 이론에서 **최소 비용 해밀턴 순환** 문제.

### 특징
- 가능한 경로의 수: `(n-1)! / 2`
- **NP-Complete 문제**
- 다항 시간에 최적해를 구하는 알고리즘은 아직 발견되지 않음

### 근사 알고리즘: 최근접 이웃법 (Nearest Neighbor)
> “미방문 도시 중 가장 가까운 도시를 먼저 방문한다.”

**예시**
- 근사해 경로: `0 → 3 → 1 → 4 → 2 → 0`  
  비용 = 89  
- 최적해 경로: `0 → 4 → 3 → 1 → 2 → 0`  
  비용 = 78  

> ✅ 빠른 근사해 가능  
> ❌ 항상 최적해는 아님

---

## 🧠 핵심 비교

| 문제 유형 | 탐욕법 적용 가능 | 최적해 보장 여부 | 대안 알고리즘 |
|------------|------------------|------------------|----------------|
| 동전 교환 | 경우에 따라 다름 | 일부 보장 | 동적계획법 |
| 분수 배낭 | 가능 | ✅ 항상 보장 | - |
| 0-1 배낭 | 불가능 | ❌ | 동적계획법 / 백트래킹 |
| TSP | 근사만 가능 | ❌ | 백트래킹 / 분기한정법 |